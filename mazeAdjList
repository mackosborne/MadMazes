import networkx as nx
import matplotlib.pyplot as plt
#--------------------SETUP and READ INPUT -----------------------------

f = open("input.txt", "r")
firstline = f.readline()
numrows = int(firstline[0])
numcolumns = int(firstline[2])
grid = []
diaggrid = []
axisgrid = []
negative = False
i=0
while i < numrows:
    ithline = f.readline()
    line = []
    for item in ithline: 
        if item == '-':
            negative = True
        elif item == '\n':
            break
        elif item != ' ' and negative == False:
            line.append(int(item))
        elif item !=  ' ' and negative == True:
            line.append(-abs(int(item)))
            negative = False  
    diaggrid.append(line)
    axisgrid.append(line)
    i=i+1
for line in axisgrid:
    grid.append(line)
for line in diaggrid:
    grid.append(line)
#Now we have a 2d Array of the maze 2x in height, and 2 Arrays Identical to the Maze
#----------------------------------------------------------------------------------

#----------------------   Build all the normal edges ------------------------------
axisedges=[]
for line in axisgrid:
    j = 0
    height = axisgrid.index(line)
    for i in line:
        location = (height*numcolumns) + j
        jumpval = abs(i)
    #Can we jump right?
        if j + jumpval < numcolumns:
            #G.add_edge(location, location+jumpval)
            tuptup = (location, location+jumpval)
            axisedges.append(tuptup)
    #Can we jump left?
        if j - jumpval >= 0:
            #G.add_edge(location, location-jumpval)
            tuptup = (location, location-jumpval)
            axisedges.append(tuptup)
    #Can we jump up?
        if height - jumpval >= 0:
            #G.add_edge(location,location-numcolumns*jumpval)
            tuptup = (location,location-numcolumns*jumpval)
            axisedges.append(tuptup)
    #Can we jump down?
        if height + jumpval < numrows:
            #G.add_edge(location,location+numcolumns*jumpval)
            tuptup = (location,location+numcolumns*jumpval)
            axisedges.append(tuptup)
        j=j+1
#-------------------   Make all Diagonal Zone Edges  ------------------
diagedges = []
for line in axisgrid:
    j = 0
    height = axisgrid.index(line)
    for i in line:
        location = ((numrows+height)*numcolumns) + j
        jumpval = abs(i)

    #Can we jump up right
        #CHANGED from jumpval < numcolumns
        if j + jumpval <= numcolumns and height - jumpval >= 0:
            #G.add_edge(location, location+jumpval)
            tuptup = (location, location-((numcolumns*jumpval)+jumpval))
            diagedges.append(tuptup)
    #Can we jump up Left?
        #CHANGED from jumpval>=0
        if j - jumpval > 0 and height - jumpval >= 0:
            #G.add_edge(location, location-jumpval)
            tuptup = (location, (location-((numcolumns*jumpval))-jumpval))
            diagedges.append(tuptup)
    #Can we jump Down Right?
        if height + jumpval < numrows and j + jumpval < numcolumns:
            #G.add_edge(location,location-numcolumns*jumpval)
            tuptup = (location,location+(numcolumns*jumpval)+jumpval)
            diagedges.append(tuptup)
    #Can we jump down Left?
        if height + jumpval < numrows and j - jumpval >= 0:
            #G.add_edge(location,location+numcolumns*jumpval)
            tuptup = (location,location+(numcolumns*jumpval)-jumpval)
            diagedges.append(tuptup)
        j=j+1
#------------------------------------------------------------------------------------------
#-  Here we draw edges for special cases:                                    --------------
#-  1) When we first enounter a negative we move to the diagonal zone(make an edge) -------
#-  2) When we hit a negative next we switch back to the axis zone (make an edge)  --------
#-  3) Hitting the goal in either zone completes the maze so we should connect them -------
#------------------------------------------------------------------------------------------
#If we hit a negative in normal land it must go to diagonal land
specedges = []
for line in axisgrid:
    j = 0
    height = axisgrid.index(line)
    for i in line:
        location = (height*numcolumns) + j
        diaglocation = ((numrows+height)*numcolumns) + j
        jumpval = abs(i)
        if i < 0:
    #Can we jump right
            if j + jumpval < numcolumns and height - jumpval >= 0:
                #G.add_edge(location, location+jumpval)
                tuptup = (location, diaglocation-(numcolumns*jumpval)+jumpval)
                specedges.append(tuptup)
    #Can we  Left?
            if j - jumpval >= 0 and height - jumpval >= 0:
            #G.add_edge(location, location-jumpval)
                tuptup = (location, diaglocation-(numcolumns*jumpval)-jumpval)
                specedges.append(tuptup)
    #Can we jump up?
            if height + jumpval < numrows and j + jumpval < numcolumns:
                #G.add_edge(location,location-numcolumns*jumpval)
                tuptup = (location,diaglocation+(numcolumns*jumpval)+jumpval)
                specedges.append(tuptup)
    #Can we jump down?
            if height + jumpval < numrows and j - jumpval >= 0:
                #G.add_edge(location,location+numcolumns*jumpval)
                tuptup = (location,diaglocation+(numcolumns*jumpval)-jumpval)
                specedges.append(tuptup)
            j=j+1

#if we hit a negative in diagonal land we must go to positive land
for line in diaggrid:
    j = 0
    height = axisgrid.index(line)
    for i in line:
        location = (height*numcolumns) + j
        diaglocation = ((numrows+height)*numcolumns) + j
        jumpval = abs(i)
    #Can we jump right?
        if j + jumpval < numcolumns:
            #G.add_edge(location, location+jumpval)
            tuptup = (diaglocation, location+jumpval)
            specedges.append(tuptup)
    #Can we jump left?
        if j - jumpval >= 0:
            #G.add_edge(location, location-jumpval)
            tuptup = (diaglocation, location-jumpval)
            specedges.append(tuptup)
    #Can we jump up?
        if height - jumpval >= 0:
            #G.add_edge(location,location-numcolumns*jumpval)
            tuptup = (diaglocation,location-numcolumns*jumpval)
            specedges.append(tuptup)
    #Can we jump down?
        if height + jumpval < numrows:
            #G.add_edge(location,location+numcolumns*jumpval)
            tuptup = (diaglocation,location+numcolumns*jumpval)
            specedges.append(tuptup)
        j=j+1
#One exta line to connect the targets
targetA = (numrows * numcolumns)-1
targetB = (2*numrows *numcolumns) - 1
tuptup = (targetA,targetB)
specedges.append(tuptup)
#-------------------------------------------------------------------------------------
#--------------Here we compine all of our Arrays of Edges-----------------------------
alledges = axisedges + diagedges + specedges  
G = nx.DiGraph()
G.add_edges_from(alledges)

#-=-=-=-=-=-=-=-=-=-=-=Implementation of Dijkstras-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
path = nx.dijkstra_path(G,0,targetB)

#--------------This Interprits the PATH into our desired output-----------------------
output = []
for step in path:
    column = step % numcolumns
    row = step // numrows
    if row>numrows:
        row=row # -numrows
    tuptup = (column,row)
    output.append(tuptup)
print(output)

#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-DRAWING ZONE-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#y = list(G.nodes)
#x = list(G.edges)  
#nx.draw(G, with_labels=True)
nx.draw(G, with_labels=True, font_weight='bold')
plt.ioff
plt.show()

#This is what I will use when it comes time to annalize
#print(nx.dijkstra_path(G,0,4))